package org.but4reuse.adapters.cppcdt.tests.dotParser;

import java.io.File;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.but4reuse.adapters.cppcdt.callhierarchy.dot.DOTParser;
import org.but4reuse.adapters.cppcdt.callhierarchy.dot.DotElement;
import org.but4reuse.adapters.cppcdt.utils.Pair;
import org.junit.Test;

import org.junit.Assert;

/**
 * This is a test suite helper for our DotParser. The dot parser is used to
 * extract the function call graph dependencies from a .dot file, generated by
 * doxygen. The input examples are in the /data/dotParser folder. Each example
 * is accompanied by a .png image that represents the actual graph.
 * 
 * All the main test logic is in this helper class.
 *
 * The graphs have been generated by doxygen (Linux) version 1.8.13 .
 * 
 * @author sandu.postaru
 *
 */

public abstract class DotParserTestHelper {

	/** Test file */
	protected File mazeFile;

	/** Elements received from the parser */
	protected Pair<List<DotElement>, List<DotElement>> dotElements;
	protected List<DotElement> functionDefNodes;
	protected List<DotElement> functionCallNodes;

	/** Expected elements to be found */
	protected Map<String, String> expectedFunctionNodes;
	protected Map<String, List<String>> expectedFunctionCalls;

	public DotParserTestHelper() {
		expectedFunctionNodes = new HashMap<String, String>();
		expectedFunctionCalls = new HashMap<String, List<String>>();
	}

	public void initialise(String fileName) {
		mazeFile = Paths.get("data", "dotParser", fileName).toFile();
		dotElements = DOTParser.parse(mazeFile);

		functionDefNodes = dotElements.first;
		functionCallNodes = dotElements.second;
	}

	@Test
	public void functionNodesTest() {
		
		// the same size for the nodes
		Assert.assertEquals(expectedFunctionNodes.size(), functionDefNodes.size());

		for (DotElement functionDef : functionDefNodes) {

			// function node
			Assert.assertEquals(DotElement.Type.FUNCTION_DEF, functionDef.type);

			// contains information
			Assert.assertNotEquals(null, functionDef.content);

			String functionId = functionDef.content.first;
			String functioName = functionDef.content.second;

			String expectedFunctionName = expectedFunctionNodes.get(functionId);

			Assert.assertEquals(expectedFunctionName, functioName);
		}
	}

	@Test
	public void functionCallsTest() {
		// the same size for the nodes
		int expectedNumberOfCalls = getNumberOfExpectedCalls();
		
		Assert.assertEquals(expectedNumberOfCalls, functionCallNodes.size());

		for (DotElement functionCall : functionCallNodes) {

			// function node
			Assert.assertEquals(DotElement.Type.FUNCTION_CALL, functionCall.type);

			// contains information
			Assert.assertNotEquals(null, functionCall.content);
			
			// Caller node
			String caller = functionCall.content.first;
			// Callee node
			String callee = functionCall.content.second;
			
			// The list of all the expected calles for this node
			List<String> callees = expectedFunctionCalls.get(caller);
			
			Assert.assertNotEquals(null, callees);
			
			// This element exists as a callee
			
			if(!callees.contains(callee)){
				Assert.fail(callee + " not present in the list of calles: ");
				
				for(String c : callees){
					System.out.println("\t-> " + c);
				}
			}
		}
	}
	
	private int getNumberOfExpectedCalls(){
		int number = 0;
		
		for(Map.Entry<String, List<String>> entry : expectedFunctionCalls.entrySet()){
			number += entry.getValue().size();
		}
		
		return number;
	}
}
